import { BlogPost } from '../../blog-posts';

export const vibeCodingSurvivalKitDeliverProd: BlogPost = {
  slug: "vibe-coding-survival-kit-deliver-prod",
  lang: "en",
  title: "From \"vibe coding\" to engineering: the survival kit to deliver in prod (without losing your flow)",
  excerpt: "Transform your fragile prototype into a robust product. A practical guide to go from AI-generated code to an application ready for 10,000 users, without sacrificing your creativity.",
  content: `
## Introduction

### Definition of "Vibe Coding"

<strong>"Vibe Coding"</strong> is the art of coding at the speed of thought, often assisted by LLMs (Claude, ChatGPT, GitHub Copilot) or AI-assisted development platforms like Lovable, Replit, or Base44. The "Vibe Coder" is a builder who prioritizes immediate visual and functional results.

### The Reality Wall

The problem is that code generated by AI or written in an intense "flow" state is often optimistic. It assumes the network is stable, users are benevolent, and the server has infinite resources.

### The Promise

This article is not here to slow down the creator with bureaucracy, but to provide them with an <strong>"exoskeleton"</strong>. This kit allows transforming a fragile prototype into a robust product, capable of welcoming its first 10,000 users without collapsing.

## 1. Maintainability: coding for your future "Self"

Code is read 10 times more often than it is written. AI writes fast, but you'll be the one to reread and debug. AI is like a human with very limited memory: it must understand the code to produce better code. Well-structured and typed code allows AI to better grasp context and avoid interpretation errors.

### Living Documentation (Strong Typing)

The "vibe" often pushes to use dynamic or loose types to avoid being blocked by the compiler. This is immediate technical debt.

**The concept**: Strict typing (e.g., TypeScript in strict mode, Type Hints in Python, or compiled languages like Go/Rust) is not a constraint, it's documentation.

**The Vibe advantage**: When you revisit the code 3 months later, or when you ask an AI to refactor a function, explicit types prevent the AI from hallucinating non-existent parameters. It's the safeguard that validates that the pieces still fit together.

**Action**: Define clear Interfaces/Contracts for all application inputs/outputs before even coding the logic.

### Modularity and "Separation of Concerns"

LLMs tend to generate monolithic 500-line files that mix database access, business logic, and user interface.

**The danger**: "Spaghetti Code". If everything is linked, modifying a button's color can break a SQL query.

**The approach**: Adopt a layered architecture or, more simply, separate the View (UI), Logic (Business Logic), and Data (Data Access).

**The essential tool**: The Linter and Formatter (e.g., ESLint/Prettier for web, Ruff/Black for Python). These tools must be configured to run on save. This delegates the mental load of formatting to the machine, allowing the brain to stay focused on the business problem.

## 2. Cybersecurity: The end of naivety

AI codes for the ideal scenario ("Happy Path"). In prod, the world is hostile.

### Identity Management (AuthN / AuthZ)

**The basic principle**: "Don't Roll Your Own Crypto".

**The trap**: Attempting to code your own login system with password hashing and session management. This is an open door to vulnerabilities.

**The modern solution**: Use managed authentication services or proven libraries (e.g., Auth0, Clerk, Supabase Auth, Lucia, or Devise for Ruby).

**Authorization (AuthZ)**: Just because a user is logged in doesn't mean they have all rights. Server-side (Backend) checks must be implemented on every request. Never trust the client: hiding an "Admin" button in the frontend is not enough if the API remains open.

### Input Validation

**The concept**: Everything coming from outside (user form, webhook, URL parameters) is potentially toxic (SQL Injections, XSS).

**The Kit**: Use runtime validation schemas (e.g., Zod for JS/TS, Pydantic for Python). These tools act as a decontamination airlock: if data doesn't match the strict schema, it's rejected before even reaching your business logic.

### Secret Management

**Golden rule**: No password, API key, or token should appear in source code (hardcoded), and even less on Git.

**Practice**: Systematically use environment variables (.env). For prod, use secret managers integrated into hosting platforms.

<strong>To identify security vulnerabilities in your AI-generated code, use our <a href="/en/audit" class="text-accent hover:text-accent/80 underline font-semibold">free security audit based on OWASP standards</a> that detects the most common vulnerabilities.</strong>

## 3. Scale and infra cost: the art of not going broke

The Vibe Coder often uses paid APIs (OpenAI, Claude, Cloud services). An infinite loop can cost a house.

### "Stateless" vs "Stateful" Architecture

**The dilemma**: To scale (grow) easily, the application should ideally be "stateless" (without state), meaning the server retains nothing in memory between two requests.

**The Cloud-Native approach**: Prefer managed services (PaaS - Platform as a Service) that handle infrastructure (e.g., Vercel, Railway, Heroku, AWS AppRunner). This allows focusing on code.

**Database**: Choose a database capable of handling simultaneous connections or use a "Connection Pooler" (especially important for Serverless architectures).

### Caching Strategy

The fastest and cheapest code is code that doesn't execute.

**Cache levels**:

- **CDN (Content Delivery Network)**: To serve static files (images, CSS, JS) as close as possible to the user.

- **Data Cache**: Use solutions like Redis or Memcached to store results of heavy queries or expensive API calls.

**Cost impact**: If your app calls an AI API on every visit, you'll go bankrupt. Caching the AI response for recurring questions is vital.

### Rate Limiting

This is the financial firewall.

**The need**: Prevent a bot or malicious user from spamming your API routes.

**Implementation**: Implement a middleware that counts requests per IP and temporarily blocks access after a certain threshold (e.g., 10 requests/minute).

## 4. Production Cycle (CI/CD): The automated factory

Manually deploying via FTP or SSH is archaic and dangerous. Deployment must be a "non-event".

### Continuous Integration (CI)

**The principle**: Every time you save your code to the central repository (e.g., GitHub, GitLab), a robot wakes up.

**Automatic checks**: This robot must:

- Install dependencies.
- Run the Linter (check style).
- Run compilation/transpilation (check syntax).
- Execute tests.

**Why is it "Vibe"?** Because it frees the mind. If the light is green, we know we haven't broken anything fundamental.

### Automated Tests: The right dose

No need to aim for 100% code coverage (which kills creativity).

**End-to-End (E2E) Tests**: Focus on "Critical Paths". Example: "A user can register, log in, and perform the main action".

**Tools**: Use modern frameworks (e.g., Playwright, Cypress, Selenium) that simulate a real browser. If this test passes, the essentials work.

### Continuous Deployment (CD)

If CI is green, code is automatically pushed to production. Zero human intervention. This encourages frequent small updates rather than scary big updates.

## 5. Pre-prod Environment: The sandbox

Testing in prod is like rehearsing a play on opening night: risky.

### The Power of Ephemeral Environments

**The concept**: For each new feature (or Pull Request), create a temporary copy of the application, accessible via a unique URL.

**Usefulness**: Allows visual testing on mobile, showing the feature to the client or colleagues, without impacting real users.

### "Staging" Data Management

**Isolation**: Never connect the test environment to the production database. An unfortunate DELETE command happens quickly.

**Seeding**: Have scripts that populate the test database with fake data (fictional users, example products). This is crucial for testing interfaces with realistic content.

**Sanitization**: If you must import data from prod to pre-prod for debugging, ensure you anonymize personal data (GDPR).

## 6. Distribution: The last mile

The code is ready, but is the product ready to be discovered?

### Observability and Monitoring

Once online, you're blind without tools.

**Structured logging**: print() or console.log() is not enough. You need logs that feed into a centralized aggregator.

**Error Tracking**: Use tools (e.g., Sentry, Bugsnag, Datadog) that notify you before users complain on Twitter. They capture the error context (browser, OS, action performed).

### Performance and Technical SEO

**Core Web Vitals**: Google judges your site on its speed. Monitor LCP (largest contentful paint time) and CLS (visual stability).

**Metadata**: Ensure each page has a title, description, and OpenGraph image (for social sharing). This is what makes the link "clickable" when shared.

### Legal and Compliance

The boring but necessary side to avoid having your service shut down.

**Mandatory pages**: Terms of Service (ToS), Privacy Policy, Legal Notices.

**Cookies**: If you track users, the consent banner is mandatory in Europe.

## Conclusion

Being a "Vibe Coder" doesn't mean being a negligent coder. On the contrary, it's using modern tools to automate rigor. By setting up this kit (Typing, CI/CD, Managed Auth, Monitoring), you build a safety net. This net allows you to continue coding fast, to attempt bold things, while having the certainty that if you stumble, the system will catch you before production breaks. That's true creative freedom.
  `,
  author: "Jonathan Serra",
  publishedAt: "2025-12-01",
  readTime: "12 min",
  tags: ["Vibe Coding", "Engineering", "Production", "DevOps", "Security", "CI/CD", "Scalability", "Best Practices"]
};